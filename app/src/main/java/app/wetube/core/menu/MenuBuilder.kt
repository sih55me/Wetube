
package app.wetube.core.menu

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.res.Configuration
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.os.Parcelable
import android.util.SparseArray
import android.view.ContextMenu.ContextMenuInfo
import android.view.KeyCharacterMap
import android.view.KeyEvent
import android.view.Menu
import android.view.MenuItem
import android.view.SubMenu
import android.view.View
import android.view.ViewConfiguration
import android.widget.PopupMenu
import java.lang.reflect.Constructor
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method


/**
 * Implementation of the [Menu] interface for creating a
 * standard menu UI.
 */
class MenuBuilder(val context: Context) : Menu {
    val resources: Resources get() = context.getResources()

    /**
     * Implementation of the [Menu] interface for creating a
     * standard menu UI.
     */
    var internalOne: Menu
        private set

    /**
     * Whether the shortcuts should be qwerty-accessible. Use isQwertyMode()
     * instead of accessing this directly.
     */
    private var mQwertyMode = false

    /**
     * Whether the shortcuts should be visible on menus. Use isShortcutsVisible()
     * instead of accessing this directly.
     */
    private var mShortcutsVisible = false

    /**
     * Callback that will receive the various menu-related events generated by
     * this class. Use getCallback to get a reference to the callback.
     */
    private var mCallback: Callback? = null

    /** Contains all of the items for this menu  */
    private val mItems: java.util.ArrayList<MenuItemImpl>

    /** Contains only the items that are currently visible.  This will be created/refreshed from
     * [.getVisibleItems]  */
    private val mVisibleItems: java.util.ArrayList<MenuItemImpl?>

    /**
     * Whether or not the items (or any one item's shown state) has changed since it was last
     * fetched from [.getVisibleItems]
     */
    private var mIsVisibleItemsStale = true

    /**
     * Contains only the items that should appear in the Action Bar, if present.
     */
    private val mActionItems: java.util.ArrayList<MenuItemImpl?>?

    /**
     * Contains items that should NOT appear in the Action Bar, if present.
     */
    private val mNonActionItems: java.util.ArrayList<MenuItemImpl?>?

    /**
     * Whether or not the items (or any one item's action state) has changed since it was
     * last fetched.
     */
    private var mIsActionItemsStale = true

    /**
     * Default value for how added items should show in the action list.
     */
    private var mDefaultShowAsAction = MenuItem.SHOW_AS_ACTION_NEVER

    /**
     * Current use case is Context Menus: As Views populate the context menu, each one has
     * extra information that should be passed along.  This is the current menu info that
     * should be set on all items added to this menu.
     */
    private var mCurrentMenuInfo: ContextMenuInfo? = null

    /** Header title for menu types that have a header (context and submenus)  */
    var headerTitle: CharSequence? = null

    /** Header icon for menu types that have a header and support icons (context)  */
    var headerIcon: Drawable? = null

    /** Header custom view for menu types that have a header and support custom views (context)  */
    var headerView: View? = null

    /**
     * Contains the state of the View hierarchy for all menu views when the menu
     * was frozen.
     */
    private val mFrozenViewStates: SparseArray<Parcelable?>? = null

    /**
     * Prevents onItemsChanged from doing its junk, useful for batching commands
     * that may individually call onItemsChanged.
     */
    private var mPreventDispatchingItemsChanged = false
    private var mItemsChangedWhileDispatchPrevented = false

    /**
     * Sets the optional icon visible.
     * @param visible true for visible, false for hidden.
     */
    var optionalIconsVisible: Boolean = false

    private val mIsClosing = false

    private val mTempShortcutItemList = java.util.ArrayList<MenuItemImpl>()


    /**
     * Currently expanded menu item; must be collapsed when we clear.
     */
    var expandedItem: MenuItemImpl? = null
        private set

    /**
     * Whether group dividers are enabled.
     */
    private var mGroupDividerEnabled = false

    fun onItemActionRequestChanged(menuItem: MenuItemImpl?) {
        var m: Method? = null
        try {
            m = internalClass!!.getDeclaredMethod(
                "onItemActionRequestChanged",
                MenuItemImpl.internalClass
            )
            m.setAccessible(true)
            m.invoke(internalOne, menuItem)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    fun onItemVisibleChanged(menuItem: MenuItemImpl?) {
        var m: Method? = null
        try {
            m = internalClass!!.getDeclaredMethod(
                "onItemVisibleChanged",
                MenuItemImpl.internalClass
            )
            m.setAccessible(true)
            m.invoke(internalOne, menuItem)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    /**
     * Called by menu to notify of close and selection changes.
     */
    interface Callback {
        /**
         * Called when a menu item is selected.
         * @param menu The menu that is the parent of the item
         * @param item The menu item that is selected
         * @return whether the menu item selection was handled
         */
        fun onMenuItemSelected(menu: MenuBuilder?, item: MenuItem?): Boolean

        /**
         * Called when the mode of the menu changes (for example, from icon to expanded).
         *
         * @param menu the menu that has changed modes
         */
        fun onMenuModeChange(menu: MenuBuilder?)
    }

    /**
     * Called by menu items to execute their associated action
     */
    interface ItemInvoker {
        fun invokeItem(item: MenuItemImpl?): Boolean
    }


    init {
        mItems = java.util.ArrayList<MenuItemImpl>()

        mVisibleItems = java.util.ArrayList<MenuItemImpl?>()

        mActionItems = java.util.ArrayList<MenuItemImpl?>()
        mNonActionItems = java.util.ArrayList<MenuItemImpl?>()
        try {
            val c: Constructor<*> = internalClass!!.getDeclaredConstructor(Context::class.java)
            c.setAccessible(true)
            internalOne = c.newInstance(context) as Menu
        } catch (e: Exception) {
            e.printStackTrace()
            throw RuntimeException("MenuBuilder not found in your phone")
        }
        setShortcutsVisibleInner(true)
    }

    fun setDefaultShowAsAction(defaultShowAsAction: Int): MenuBuilder {
        mDefaultShowAsAction = defaultShowAsAction
        return this
    }


    @Throws(
        NoSuchMethodException::class,
        InvocationTargetException::class,
        IllegalAccessException::class
    )
    fun savePresenterStates(outState: Bundle?) {
        val m: Method =
            internalClass!!.getDeclaredMethod("dispatchSaveInstanceState", Bundle::class.java)
        m.setAccessible(true)
        m.invoke(internalOne, outState)
    }

    @Throws(
        InvocationTargetException::class,
        IllegalAccessException::class,
        NoSuchMethodException::class
    )
    fun restorePresenterStates(state: Bundle?) {
        val m: Method =
            internalClass!!.getDeclaredMethod("dispatchRestoreInstanceState", Bundle::class.java)
        m.setAccessible(true)
        m.invoke(internalOne, state)
    }


    fun setCallback(cb: Callback?) {
        mCallback = cb
    }

    /**
     * Adds an item to the menu.  The other add methods funnel to this.
     */
    private fun addInternal(
        group: Int,
        id: Int,
        categoryOrder: Int,
        title: CharSequence?
    ): MenuItem {
        val item = createNewMenuItem(
            group, id, categoryOrder, 0, title,
            mDefaultShowAsAction
        )

        if (mCurrentMenuInfo != null) {
            // Pass along the current menu info
            item.setMenuInfo(mCurrentMenuInfo)
        }

        mItems.add(findInsertIndex(mItems, 0), item)
        onItemsChanged(true)

        return item
    }

    // Layoutlib overrides this method to return its custom implementation of MenuItemImpl
    private fun createNewMenuItem(
        group: Int, id: Int, categoryOrder: Int, ordering: Int,
        title: CharSequence?, defaultShowAsAction: Int
    ): MenuItemImpl {
        return MenuItemImpl(
            this, group, id, categoryOrder, ordering, title,
            defaultShowAsAction
        )
    }

    override fun add(title: CharSequence?): MenuItem {
        return addInternal(0, 0, 0, title)
    }

    override fun add(titleRes: Int): MenuItem {
        return addInternal(0, 0, 0, resources.getString(titleRes))
    }

    override fun add(group: Int, id: Int, categoryOrder: Int, title: CharSequence?): MenuItem {
        return addInternal(group, id, categoryOrder, title)
    }

    override fun add(group: Int, id: Int, categoryOrder: Int, title: Int): MenuItem {
        return addInternal(group, id, categoryOrder, resources.getString(title))
    }

    override fun addSubMenu(title: CharSequence?): SubMenu? {
        return addSubMenu(0, 0, 0, title)
    }

    override fun addSubMenu(titleRes: Int): SubMenu? {
        return addSubMenu(0, 0, 0, resources.getString(titleRes))
    }

    override fun addSubMenu(
        group: Int,
        id: Int,
        categoryOrder: Int,
        title: CharSequence?
    ): SubMenu? {
        return null
    }

    override fun addSubMenu(group: Int, id: Int, categoryOrder: Int, title: Int): SubMenu? {
        return addSubMenu(group, id, categoryOrder, resources.getString(title))
    }

    override fun setGroupDividerEnabled(groupDividerEnabled: Boolean) {
        mGroupDividerEnabled = groupDividerEnabled
    }

    fun isGroupDividerEnabled(): Boolean {
        return mGroupDividerEnabled
    }

    override fun addIntentOptions(
        group: Int, id: Int, categoryOrder: Int, caller: ComponentName?,
        specifics: Array<Intent?>, intent: Intent, flags: Int, outSpecificItems: Array<MenuItem?>?
    ): Int {
        val pm = context.getPackageManager()
        val lri =
            pm.queryIntentActivityOptions(caller, specifics, intent, 0)
        val N = if (lri != null) lri.size else 0

        if ((flags and Menu.FLAG_APPEND_TO_GROUP) == 0) {
            removeGroup(group)
        }

        for (i in 0..<N) {
            val ri = lri.get(i)
            val rintent = Intent(
                if (ri.specificIndex < 0) intent else specifics[ri.specificIndex]
            )
            rintent.setComponent(
                ComponentName(
                    ri.activityInfo.applicationInfo.packageName,
                    ri.activityInfo.name
                )
            )
            val item = add(group, id, categoryOrder, ri.loadLabel(pm))
                .setIcon(ri.loadIcon(pm))
                .setIntent(rintent)
            if (outSpecificItems != null && ri.specificIndex >= 0) {
                outSpecificItems[ri.specificIndex] = item
            }
        }

        return N
    }

    override fun removeItem(id: Int) {
        removeItemAtInt(findItemIndex(id), true)
    }

    override fun removeGroup(group: Int) {
        val i = findGroupIndex(group)

        if (i >= 0) {
            val maxRemovable = mItems.size - i
            var numRemoved = 0
            while ((numRemoved++ < maxRemovable) && (mItems.get(i).getGroupId() == group)) {
                // Don't force update for each one, this method will do it at the end
                removeItemAtInt(i, false)
            }

            // Notify menu views
            onItemsChanged(true)
        }
    }

    /**
     * Remove the item at the given index and optionally forces menu views to
     * update.
     *
     * @param index The index of the item to be removed. If this index is
     * invalid an exception is thrown.
     * @param updateChildrenOnMenuViews Whether to force update on menu views.
     * Please make sure you eventually call this after your batch of
     * removals.
     */
    private fun removeItemAtInt(index: Int, updateChildrenOnMenuViews: Boolean) {
        if ((index < 0) || (index >= mItems.size)) return

        mItems.removeAt(index)

        if (updateChildrenOnMenuViews) onItemsChanged(true)
    }

    fun removeItemAt(index: Int) {
        removeItemAtInt(index, true)
    }

    fun clearAll() {
        mPreventDispatchingItemsChanged = true
        clear()
        clearHeader()
        mPreventDispatchingItemsChanged = false
        mItemsChangedWhileDispatchPrevented = false
        onItemsChanged(true)
    }

    override fun clear() {
        if (this.expandedItem != null) {
            collapseItemActionView(this.expandedItem!!)
        }
        mItems.clear()

        onItemsChanged(true)
    }

    fun setExclusiveItemChecked(item: MenuItem) {
        val group = item.getGroupId()

        val N = mItems.size
        for (i in 0..<N) {
            val curItem = mItems.get(i)
            if (curItem.getGroupId() == group) {
                if (!curItem.isExclusiveCheckable) continue
                if (!curItem.isCheckable) continue

                // Check the item meant to be checked, uncheck the others (that are in the group)
                curItem.setCheckedInt(curItem == item)
            }
        }
    }

    override fun setGroupCheckable(group: Int, checkable: Boolean, exclusive: Boolean) {
        val N = mItems.size

        for (i in 0..<N) {
            val item = mItems.get(i)
            if (item.getGroupId() == group) {

                item.isExclusiveCheckable = (exclusive)
                item.setCheckable(checkable)
            }
        }
    }

    override fun setGroupVisible(group: Int, visible: Boolean) {
        val N = mItems.size

        // We handle the notification of items being changed ourselves, so we use setVisibleInt rather
        // than setVisible and at the end notify of items being changed
        var changedAtLeastOneItem = false
        for (i in 0..<N) {
            val item = mItems.get(i)
            if (item.getGroupId() == group) {
                if (item.setVisibleInt(visible)) changedAtLeastOneItem = true
            }
        }

        if (changedAtLeastOneItem) onItemsChanged(true)
    }

    override fun setGroupEnabled(group: Int, enabled: Boolean) {
        val N = mItems.size

        for (i in 0..<N) {
            val item = mItems.get(i)
            if (item.getGroupId() == group) {
                item.setEnabled(enabled)
            }
        }
    }

    override fun hasVisibleItems(): Boolean {
        val size = size()

        for (i in 0..<size) {
            val item = mItems.get(i)
            if (item.isVisible()) {
                return true
            }
        }

        return false
    }

    override fun findItem(id: Int): MenuItem? {
        val size = size()
        for (i in 0..<size) {
            val item = mItems.get(i)
            if (item.getItemId() == id) {
                return item
            } else if (item.hasSubMenu()) {
                val possibleItem = item.getSubMenu()!!.findItem(id)

                if (possibleItem != null) {
                    return possibleItem
                }
            }
        }

        return null
    }

    fun findItemIndex(id: Int): Int {
        val size = size()

        for (i in 0..<size) {
            val item = mItems.get(i)
            if (item.getItemId() == id) {
                return i
            }
        }

        return -1
    }

    @JvmOverloads
    fun findGroupIndex(group: Int, start: Int = 0): Int {
        var start = start
        val size = size()

        if (start < 0) {
            start = 0
        }

        for (i in start..<size) {
            val item = mItems.get(i)

            if (item.getGroupId() == group) {
                return i
            }
        }

        return -1
    }

    override fun size(): Int {
        return mItems.size
    }

    /** {@inheritDoc}  */
    override fun getItem(index: Int): MenuItem? {
        return mItems.get(index)
    }

    override fun isShortcutKey(keyCode: Int, event: KeyEvent): Boolean {
        return findItemWithShortcutForKey(keyCode, event) != null
    }

    override fun setQwertyMode(isQwerty: Boolean) {
        mQwertyMode = isQwerty

        onItemsChanged(false)
    }


    /**
     * @return whether the menu shortcuts are in qwerty mode or not
     */
    fun isQwertyMode(): Boolean {
        return mQwertyMode
    }

    private fun setShortcutsVisibleInner(shortcutsVisible: Boolean) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            mShortcutsVisible = shortcutsVisible
                    && resources.getConfiguration().keyboard != Configuration.KEYBOARD_NOKEYS && ViewConfiguration.get(
                this.context
            ).shouldShowMenuShortcutsWhenKeyboardPresent()
        }
    }

    var isShortcutsVisible: Boolean
        /**
         * @return Whether shortcuts should be visible on menus.
         */
        get() = mShortcutsVisible
        /**
         * Sets whether the shortcuts should be visible on menus.  Devices without hardware
         * key input will never make shortcuts visible even if this method is passed 'true'.
         *
         * @param shortcutsVisible Whether shortcuts should be visible (if true and a
         * menu item does not have a shortcut defined, that item will
         * still NOT show a shortcut)
         */
        set(shortcutsVisible) {
            if (mShortcutsVisible == shortcutsVisible) return

            setShortcutsVisibleInner(shortcutsVisible)
            onItemsChanged(false)
        }


    fun dispatchMenuItemSelected(menu: MenuBuilder?, item: MenuItem?): Boolean {
        return mCallback != null && mCallback!!.onMenuItemSelected(menu, item)
    }

    /**
     * Dispatch a mode change event to this menu's callback.
     */
    fun changeMenuMode() {
        if (mCallback != null) {
            mCallback!!.onMenuModeChange(this)
        }
    }

    override fun performShortcut(keyCode: Int, event: KeyEvent, flags: Int): Boolean {
        val item = findItemWithShortcutForKey(keyCode, event)

        var handled = false

        if (item != null) {
            handled = performItemAction(item, flags)
        }

        if ((flags and Menu.FLAG_ALWAYS_PERFORM_CLOSE) != 0) {
            close(true /* closeAllMenus */)
        }

        return handled
    }

    /*
     * This function will return all the menu and sub-menu items that can
     * be directly (the shortcut directly corresponds) and indirectly
     * (the ALT-enabled char corresponds to the shortcut) associated
     * with the keyCode.
     */
    fun findItemsWithShortcutForKey(
        items: MutableList<MenuItemImpl>,
        keyCode: Int,
        event: KeyEvent
    ) {
        val qwerty = isQwertyMode()
        val modifierState = event.getModifiers()
        val possibleChars = KeyCharacterMap.KeyData()
        // Get the chars associated with the keyCode (i.e using any chording combo)
        val isKeyCodeMapped = event.getKeyData(possibleChars)
        // The delete key is not mapped to '\b' so we treat it specially
        if (!isKeyCodeMapped && (keyCode != KeyEvent.KEYCODE_DEL)) {
            return
        }

        // Look for an item whose shortcut is this key.
        val N = mItems.size
        for (i in 0..<N) {
            val item = mItems.get(i)
            if (item.hasSubMenu()) {
                (item.getSubMenu() as MenuBuilder).findItemsWithShortcutForKey(
                    items,
                    keyCode,
                    event
                )
            }
            val shortcutChar =
                if (qwerty) item.getAlphabeticShortcut() else item.getNumericShortcut()
            val shortcutModifiers =
                if (qwerty) item.getAlphabeticModifiers() else item.getNumericModifiers()
            val isModifiersExactMatch = ((modifierState and Menu.SUPPORTED_MODIFIERS_MASK)
                    == (shortcutModifiers and Menu.SUPPORTED_MODIFIERS_MASK))
            if (isModifiersExactMatch && (shortcutChar.code != 0) &&
                (shortcutChar == possibleChars.meta[0] || shortcutChar == possibleChars.meta[2] || (qwerty && shortcutChar == '\b' && keyCode == KeyEvent.KEYCODE_DEL)) &&
                item.isEnabled()
            ) {
                items.add(item)
            }
        }
    }

    /*
     * We want to return the menu item associated with the key, but if there is no
     * ambiguity (i.e. there is only one menu item corresponding to the key) we want
     * to return it even if it's not an exact match; this allow the user to
     * _not_ use the ALT key for example, making the use of shortcuts slightly more
     * user-friendly. An example is on the G1, '!' and '1' are on the same key, and
     * in Gmail, Menu+1 will trigger Menu+! (the actual shortcut).
     *
     * On the other hand, if two (or more) shortcuts corresponds to the same key,
     * we have to only return the exact match.
     */
    fun findItemWithShortcutForKey(keyCode: Int, event: KeyEvent): MenuItemImpl? {
        // Get all items that can be associated directly or indirectly with the keyCode
        val items = mTempShortcutItemList
        items.clear()
        findItemsWithShortcutForKey(items, keyCode, event)

        if (items.isEmpty()) {
            return null
        }

        val metaState = event.getMetaState()
        val possibleChars = KeyCharacterMap.KeyData()
        // Get the chars associated with the keyCode (i.e using any chording combo)
        event.getKeyData(possibleChars)

        // If we have only one element, we can safely returns it
        val size = items.size
        if (size == 1) {
            return items.get(0)
        }

        val qwerty = isQwertyMode()
        // If we found more than one item associated with the key,
        // we have to return the exact match
        for (i in 0..<size) {
            val item = items.get(i)
            val shortcutChar =
                if (qwerty) item.getAlphabeticShortcut() else item.getNumericShortcut()
            if ((shortcutChar == possibleChars.meta[0] &&
                        (metaState and KeyEvent.META_ALT_ON) == 0)
                || (shortcutChar == possibleChars.meta[2] &&
                        (metaState and KeyEvent.META_ALT_ON) != 0)
                || (qwerty && shortcutChar == '\b' && keyCode == KeyEvent.KEYCODE_DEL)
            ) {
                return item
            }
        }
        return null
    }

    override fun performIdentifierAction(id: Int, flags: Int): Boolean {
        // Look for an item whose identifier is the id.
        return performItemAction(findItem(id), flags)
    }

    fun performItemAction(item: MenuItem?, flags: Int): Boolean {
        var result: Boolean
        try {
            val m: Method = internalClass!!.getDeclaredMethod(
                "performItemAction",
                MenuItem::class.java,
                Int::class.java
            )
            m.setAccessible(true)
            result = (m.invoke(internalOne, item, flags) as kotlin.Boolean?)!!
        } catch (e: Exception) {
            result = false
        }
        return result
    }


    /**
     * Closes the menu.
     *
     * @param closeAllMenus `true` if all displayed menus and submenus
     * should be completely closed (as when a menu item is
     * selected) or `false` if only this menu should
     * be closed
     */
    fun close(closeAllMenus: Boolean) {
        var m: Method? = null
        try {
            m = internalClass!!.getDeclaredMethod("close", Boolean::class.java)
            m.setAccessible(true)
            m.invoke(internalOne, closeAllMenus)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    /** {@inheritDoc}  */
    override fun close() {
        try {
            close(true /* closeAllMenus */)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }


    val visibleItems: ArrayList<MenuItemImpl?>
        get() {
            if (!mIsVisibleItemsStale) return mVisibleItems

            // Refresh the visible items
            mVisibleItems.clear()

            val itemsSize = mItems.size
            var item: MenuItemImpl
            for (i in 0..<itemsSize) {
                item = mItems.get(i)
                if (item.isVisible()) mVisibleItems.add(item)
            }

            mIsVisibleItemsStale = false
            mIsActionItemsStale = true

            return mVisibleItems
        }

    /**
     * This method determines which menu items get to be 'action items' that will appear
     * in an action bar and which items should be 'overflow items' in a secondary menu.
     * The rules are as follows:
     *
     *
     * Items are considered for inclusion in the order specified within the menu.
     * There is a limit of mMaxActionItems as a total count, optionally including the overflow
     * menu button itself. This is a soft limit; if an item shares a group ID with an item
     * previously included as an action item, the new item will stay with its group and become
     * an action item itself even if it breaks the max item count limit. This is done to
     * limit the conceptual complexity of the items presented within an action bar. Only a few
     * unrelated concepts should be presented to the user in this space, and groups are treated
     * as a single concept.
     *
     *
     * There is also a hard limit of consumed measurable space: mActionWidthLimit. This
     * limit may be broken by a single item that exceeds the remaining space, but no further
     * items may be added. If an item that is part of a group cannot fit within the remaining
     * measured width, the entire group will be demoted to overflow. This is done to ensure room
     * for navigation and other affordances in the action bar as well as reduce general UI clutter.
     *
     *
     * The space freed by demoting a full group cannot be consumed by future menu items.
     * Once items begin to overflow, all future items become overflow items as well. This is
     * to avoid inadvertent reordering that may break the app's intended design.
     */
    fun flagActionItems() {
        // Important side effect: if getVisibleItems is stale it may refresh,
        // which can affect action items staleness.
        try {
            val m: Method = internalClass!!.getDeclaredMethod("flagActionItems")
            m.setAccessible(true)
            m.invoke(internalOne)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    val actionItems: ArrayList<MenuItemImpl?>?
        get() {
            flagActionItems()
            return mActionItems
        }


    val nonActionItems: ArrayList<MenuItemImpl?>?
        get() {
            flagActionItems()
            return mNonActionItems
        }

    fun clearHeader() {
        this.headerIcon = null
        this.headerTitle = null
        this.headerView = null

        onItemsChanged(false)
    }

    fun onItemsChanged(b: Boolean) {
        try {
            val m: Method = internalClass!!.getDeclaredMethod("onItemsChanged", Boolean::class.java)
            m.setAccessible(true)
            m.invoke(internalOne, b)
        } catch (e: Exception) {
            throw RuntimeException(e)
        }
    }

    private fun setHeaderInternal(
        titleRes: Int, title: CharSequence?, iconRes: Int,
        icon: Drawable?, view: View?
    ) {
        val r = this.resources

        if (view != null) {
            this.headerView = view

            // If using a custom view, then the title and icon aren't used
            this.headerTitle = null
            this.headerIcon = null
        } else {
            if (titleRes > 0) {
                this.headerTitle = r.getText(titleRes)
            } else if (title != null) {
                this.headerTitle = title
            }

            if (iconRes > 0) {
                this.headerIcon = this.context.getDrawable(iconRes)
            } else if (icon != null) {
                this.headerIcon = icon
            }

            // If using the title or icon, then a custom view isn't used
            this.headerView = null
        }

        // Notify of change
        onItemsChanged(false)
    }

    /**
     * Sets the header's title. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param title The new title.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected fun setHeaderTitleInt(title: CharSequence?): MenuBuilder {
        setHeaderInternal(0, title, 0, null, null)
        return this
    }

    /**
     * Sets the header's title. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param titleRes The new title (as a resource ID).
     * @return This MenuBuilder so additional setters can be called.
     */
    protected fun setHeaderTitleInt(titleRes: Int): MenuBuilder {
        setHeaderInternal(titleRes, null, 0, null, null)
        return this
    }

    /**
     * Sets the header's icon. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param icon The new icon.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected fun setHeaderIconInt(icon: Drawable?): MenuBuilder {
        setHeaderInternal(0, null, 0, icon, null)
        return this
    }

    /**
     * Sets the header's icon. This replaces the header view. Called by the
     * builder-style methods of subclasses.
     *
     * @param iconRes The new icon (as a resource ID).
     * @return This MenuBuilder so additional setters can be called.
     */
    protected fun setHeaderIconInt(iconRes: Int): MenuBuilder {
        setHeaderInternal(0, null, iconRes, null, null)
        return this
    }

    /**
     * Sets the header's view. This replaces the title and icon. Called by the
     * builder-style methods of subclasses.
     *
     * @param view The new view.
     * @return This MenuBuilder so additional setters can be called.
     */
    protected fun setHeaderViewInt(view: View?): MenuBuilder {
        setHeaderInternal(0, null, 0, null, view)
        return this
    }


    val rootMenu: MenuBuilder
        /**
         * Gets the root menu (if this is a submenu, find its root menu).
         * @return The root menu.
         */
        get() = this

    /**
     * Sets the current menu info that is set on all items added to this menu
     * (until this is called again with different menu info, in which case that
     * one will be added to all subsequent item additions).
     *
     * @param menuInfo The extra menu information to add.
     */
    fun setCurrentMenuInfo(menuInfo: ContextMenuInfo?) {
        mCurrentMenuInfo = menuInfo
    }

    fun expandItemActionView(item: MenuItemImpl): Boolean {
        var expanded: Boolean
        var m: Method? = null
        try {
            m = internalClass!!.getDeclaredMethod(
                "expandItemActionView",
                MenuItemImpl.internalClass
            )
            m.setAccessible(true)
            expanded = (m.invoke(internalOne, item.internalOne) as kotlin.Boolean?)!!
        } catch (e: Exception) {
            expanded = false
        }
        return expanded
    }


    fun collapseItemActionView(item: MenuItemImpl): Boolean {
        var collapsed: Boolean
        var m: Method? = null
        try {
            m = internalClass!!.getDeclaredMethod(
                "collapseItemActionView",
                MenuItemImpl.internalClass
            )
            m.setAccessible(true)
            collapsed = (m.invoke(internalOne, item.internalOne) as kotlin.Boolean?)!!
        } catch (e: Exception) {
            collapsed = false
        }


        if (collapsed) {
            this.expandedItem = null
        }
        return collapsed
    }

    companion object {
        private val sCategoryToOrder = intArrayOf(
            1,  /* No category */
            4,  /* CONTAINER */
            5,  /* SYSTEM */
            3,  /* SECONDARY */
            2,  /* ALTERNATIVE */
            0,  /* SELECTED_ALTERNATIVE */
        )



        val internalClass: Class<*> get() {
            try {
                return Class.forName("com.android.internal.view.menu.MenuBuilder")
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        }


        fun createFresh(context: Context, onClick: PopupMenu.OnMenuItemClickListener? = null): Menu {
            val p = PopupMenu(context, null)
            onClick?.let {
                p.setOnMenuItemClickListener(it)
            }
            return p.menu
        }



        private fun findInsertIndex(items: java.util.ArrayList<MenuItemImpl>, ordering: Int): Int {
            for (i in items.indices.reversed()) {
                val item = items.get(i)
                if (item.ordering <= ordering) {
                    return i + 1
                }
            }

            return 0
        }
    }
}

